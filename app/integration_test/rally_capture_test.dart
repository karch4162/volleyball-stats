import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:integration_test/integration_test.dart';
import 'package:volleyball_stats_app/core/persistence/hive_service.dart';
import 'package:volleyball_stats_app/core/router/app_router.dart';
import 'package:volleyball_stats_app/core/theme/app_theme.dart';
import 'package:volleyball_stats_app/features/match_setup/match_setup_flow.dart';
import 'package:volleyball_stats_app/features/rally_capture/rally_capture_screen.dart';

import 'utils/screenshot_helper.dart';
// mock_data.dart available if needed for creating mock players/teams

void main() {
  final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized();
  final screenshotHelper = ScreenshotHelper(binding);

  setUpAll(() async {
    // Initialize Hive for Flutter in test mode
    await Hive.initFlutter();
  });

  tearDownAll(() async {
    await HiveService.closeAll();
  });

  setUp(() async {
    // Clean up any previous state before each test
    await HiveService.initialize();
  });

  tearDown(() async {
    await HiveService.closeAll();
  });

  /// Helper to pump the app widget
  Future<void> pumpApp(WidgetTester tester, {String initialRoute = '/'}) async {
    final app = ProviderScope(
      child: MaterialApp.router(
        title: 'Volleyball Stats',
        theme: AppTheme.darkTheme,
        debugShowCheckedModeBanner: false,
        routerConfig: appRouter,
      ),
    );

    await tester.pumpWidget(app);
    await tester.pumpAndSettle();

    // Navigate to initial route if needed
    if (initialRoute != '/') {
      appRouter.go(initialRoute);
      await tester.pumpAndSettle();
    }
  }

  /// Helper to set up a match and navigate to rally capture
  /// This goes through match setup flow to create a valid match state
  Future<String?> setupMatchAndNavigateToRallyCapture(WidgetTester tester) async {
    // Start at match setup
    await pumpApp(tester, initialRoute: '/match/setup');
    await tester.pumpAndSettle(const Duration(seconds: 3));

    // Fill in required match info
    final opponentField = find.widgetWithText(TextField, 'Opponent');
    if (opponentField.evaluate().isNotEmpty) {
      await tester.enterText(opponentField, 'Test Opponent');
      await tester.pumpAndSettle();
    }

    // Select date
    final dateButton = find.byIcon(Icons.calendar_today);
    if (dateButton.evaluate().isNotEmpty) {
      await tester.tap(dateButton);
      await tester.pumpAndSettle();
      final okButton = find.text('OK');
      if (okButton.evaluate().isNotEmpty) {
        await tester.tap(okButton);
        await tester.pumpAndSettle();
      }
    }

    // Select 6 players
    final filterChips = find.byType(FilterChip);
    if (filterChips.evaluate().isNotEmpty) {
      final chipCount = filterChips.evaluate().length;
      final selectCount = chipCount >= 6 ? 6 : chipCount;

      for (var i = 0; i < selectCount; i++) {
        await tester.tap(filterChips.at(i));
        await tester.pumpAndSettle();
      }
    }

    // Scroll to rotation section and assign players
    await tester.scrollUntilVisible(
      find.text('Starting Rotation'),
      100,
      scrollable: find.byType(Scrollable).first,
    );
    await tester.pumpAndSettle();

    // Assign rotation positions (1-6)
    for (var position = 1; position <= 6; position++) {
      final rotationSlot = find.byKey(ValueKey('rotation-$position'));
      if (rotationSlot.evaluate().isNotEmpty) {
        await tester.tap(rotationSlot);
        await tester.pumpAndSettle();

        // Select a player from the picker (skip Clear option at index 0)
        final listTiles = find.byType(ListTile);
        if (listTiles.evaluate().length > position) {
          await tester.tap(listTiles.at(position));
          await tester.pumpAndSettle();
        } else if (listTiles.evaluate().length > 1) {
          await tester.tap(listTiles.at(1));
          await tester.pumpAndSettle();
        }
      }
    }

    // Scroll to Start Match button
    await tester.scrollUntilVisible(
      find.text('Start Match'),
      100,
      scrollable: find.byType(Scrollable).first,
    );
    await tester.pumpAndSettle();

    // Tap Start Match if enabled
    final startMatchButton = find.widgetWithText(FilledButton, 'Start Match');
    if (startMatchButton.evaluate().isNotEmpty) {
      final FilledButton button = tester.widget(startMatchButton);
      if (button.onPressed != null) {
        await tester.tap(startMatchButton);
        await tester.pumpAndSettle(const Duration(seconds: 3));
        return 'test-match-id'; // Match ID would be generated by the system
      }
    }

    return null;
  }

  /// Helper to navigate directly to rally capture with a test match ID
  Future<void> navigateToRallyCapture(WidgetTester tester, String matchId) async {
    appRouter.go('/match/$matchId/rally');
    await tester.pumpAndSettle(const Duration(seconds: 3));
  }

  // ============================================================
  // QUICK ACTIONS TESTS (1-3)
  // ============================================================

  group('Quick Actions Tests', () {
    testWidgets('1. Point Won button increments team score and records rally', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      // Take screenshot of initial state
      await screenshotHelper.takeScreenshot('rally_capture_initial');

      // Check if RallyCaptureScreen is displayed
      final rallyCaptureScreen = find.byType(RallyCaptureScreen);
      if (rallyCaptureScreen.evaluate().isEmpty) {
        // If rally capture screen not found, try setting up a match first
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find Point Won button
      final pointWonButton = find.text('Point Won');
      if (pointWonButton.evaluate().isNotEmpty) {
        // Take screenshot before tapping
        await screenshotHelper.takeScreenshot('rally_point_won_before');

        // Tap Point Won
        await tester.tap(pointWonButton);
        await tester.pumpAndSettle();

        // Take screenshot after tapping
        await screenshotHelper.takeScreenshot('rally_point_won_after');

        // Verify snackbar message appears
        expect(find.textContaining('Point'), findsWidgets);
      }
    });

    testWidgets('2. Point Lost button increments opponent score', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      // Check if we're on rally capture screen
      final rallyCaptureScreen = find.byType(RallyCaptureScreen);
      if (rallyCaptureScreen.evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Take screenshot of initial state
      await screenshotHelper.takeScreenshot('rally_point_lost_before');

      // Find Point Lost button
      final pointLostButton = find.text('Point Lost');
      if (pointLostButton.evaluate().isNotEmpty) {
        // Tap Point Lost
        await tester.tap(pointLostButton);
        await tester.pumpAndSettle();

        // Take screenshot after tapping
        await screenshotHelper.takeScreenshot('rally_point_lost_after');

        // Verify snackbar message appears
        expect(find.textContaining('Point'), findsWidgets);
      }
    });

    testWidgets('3. Undo button reverts last action', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      // Check if we're on rally capture screen
      final rallyCaptureScreen = find.byType(RallyCaptureScreen);
      if (rallyCaptureScreen.evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // First, record an action
      final pointWonButton = find.text('Point Won');
      if (pointWonButton.evaluate().isNotEmpty) {
        await tester.tap(pointWonButton);
        await tester.pumpAndSettle();
      }

      // Take screenshot after action
      await screenshotHelper.takeScreenshot('rally_undo_action_recorded');

      // Find Undo button
      final undoButton = find.text('Undo');
      if (undoButton.evaluate().isNotEmpty) {
        // Tap Undo
        await tester.tap(undoButton);
        await tester.pumpAndSettle();

        // Take screenshot after undo
        await screenshotHelper.takeScreenshot('rally_undo_action_reverted');
      }
    });
  });

  // ============================================================
  // PLAYER STATS TESTS (4-11)
  // ============================================================

  group('Player Stats Tests', () {
    testWidgets('4. Kill button records attack kill for player', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      // Check if we're on rally capture screen
      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Take screenshot of player stats section
      await screenshotHelper.takeScreenshot('rally_player_stats_initial');

      // Find a Kill button on a player card
      final killButton = find.text('Kill');
      if (killButton.evaluate().isNotEmpty) {
        // Tap first Kill button
        await tester.tap(killButton.first);
        await tester.pumpAndSettle();

        // Take screenshot after recording kill
        await screenshotHelper.takeScreenshot('rally_kill_recorded');

        // Verify snackbar shows kill recorded
        expect(find.textContaining('Kill'), findsWidgets);
      }
    });

    testWidgets('5. Attack Error button records error for player', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find Attack Error button (labeled 'Atk Err')
      final atkErrButton = find.text('Atk Err');
      if (atkErrButton.evaluate().isNotEmpty) {
        await tester.tap(atkErrButton.first);
        await tester.pumpAndSettle();

        // Take screenshot after recording error
        await screenshotHelper.takeScreenshot('rally_attack_error_recorded');

        // Verify snackbar shows error recorded
        expect(find.textContaining('Error'), findsWidgets);
      }
    });

    testWidgets('6. Block button records block for player', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find Block button
      final blockButton = find.text('Block');
      if (blockButton.evaluate().isNotEmpty) {
        await tester.tap(blockButton.first);
        await tester.pumpAndSettle();

        // Take screenshot after recording block
        await screenshotHelper.takeScreenshot('rally_block_recorded');

        // Verify block recorded
        expect(find.textContaining('Block'), findsWidgets);
      }
    });

    testWidgets('7. Dig button records dig for player', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find Dig button
      final digButton = find.text('Dig');
      if (digButton.evaluate().isNotEmpty) {
        await tester.tap(digButton.first);
        await tester.pumpAndSettle();

        // Take screenshot after recording dig
        await screenshotHelper.takeScreenshot('rally_dig_recorded');

        // Verify dig recorded
        expect(find.textContaining('Dig'), findsWidgets);
      }
    });

    testWidgets('8. Assist button records assist for player', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find Assist button
      final assistButton = find.text('Assist');
      if (assistButton.evaluate().isNotEmpty) {
        await tester.tap(assistButton.first);
        await tester.pumpAndSettle();

        // Take screenshot after recording assist
        await screenshotHelper.takeScreenshot('rally_assist_recorded');

        // Verify assist recorded
        expect(find.textContaining('Assist'), findsWidgets);
      }
    });

    testWidgets('9. Ace button records serve ace for player', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find Ace button
      final aceButton = find.text('Ace');
      if (aceButton.evaluate().isNotEmpty) {
        await tester.tap(aceButton.first);
        await tester.pumpAndSettle();

        // Take screenshot after recording ace
        await screenshotHelper.takeScreenshot('rally_ace_recorded');

        // Verify ace recorded (auto-completes rally with win)
        expect(find.textContaining('Ace'), findsWidgets);
      }
    });

    testWidgets('10. Serve Error button records serve error for player', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find Serve Error button (labeled 'Srv Err')
      final srvErrButton = find.text('Srv Err');
      if (srvErrButton.evaluate().isNotEmpty) {
        await tester.tap(srvErrButton.first);
        await tester.pumpAndSettle();

        // Take screenshot after recording serve error
        await screenshotHelper.takeScreenshot('rally_serve_error_recorded');

        // Verify serve error recorded (auto-completes rally with loss)
        expect(find.textContaining('Error'), findsWidgets);
      }
    });

    testWidgets('11. FBK button records first ball kill for player', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find FBK button
      final fbkButton = find.text('FBK');
      if (fbkButton.evaluate().isNotEmpty) {
        await tester.tap(fbkButton.first);
        await tester.pumpAndSettle();

        // Take screenshot after recording FBK
        await screenshotHelper.takeScreenshot('rally_fbk_recorded');

        // Verify FBK recorded (auto-completes rally with win)
        expect(find.textContaining('FBK'), findsWidgets);
      }
    });
  });

  // ============================================================
  // UI COMPONENTS TESTS (12-14)
  // ============================================================

  group('UI Components Tests', () {
    testWidgets('12. Score card expand/collapse functionality', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Take screenshot of initial state (expanded)
      await screenshotHelper.takeScreenshot('rally_score_card_expanded');

      // Find the expand/collapse icon for score card
      // The score card header is tappable and contains expand_less/expand_more icon
      final expandLessIcon = find.byIcon(Icons.expand_less_rounded);
      final scoreCardHeader = find.textContaining('Match');

      if (expandLessIcon.evaluate().isNotEmpty) {
        // Tap to collapse
        await tester.tap(expandLessIcon.first);
        await tester.pumpAndSettle();

        // Take screenshot of collapsed state
        await screenshotHelper.takeScreenshot('rally_score_card_collapsed');

        // Find expand_more icon to expand again
        final expandMoreIcon = find.byIcon(Icons.expand_more_rounded);
        if (expandMoreIcon.evaluate().isNotEmpty) {
          await tester.tap(expandMoreIcon.first);
          await tester.pumpAndSettle();

          // Take screenshot of re-expanded state
          await screenshotHelper.takeScreenshot('rally_score_card_reexpanded');
        }
      } else if (scoreCardHeader.evaluate().isNotEmpty) {
        // Try tapping the header directly
        await tester.tap(scoreCardHeader.first);
        await tester.pumpAndSettle();

        await screenshotHelper.takeScreenshot('rally_score_card_toggled');
      }
    });

    testWidgets('13. Recent rallies section updates with recorded actions', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Scroll to Recent Rallies section
      await tester.scrollUntilVisible(
        find.text('Recent Rallies'),
        100,
        scrollable: find.byType(Scrollable).first,
      );
      await tester.pumpAndSettle();

      // Take screenshot of initial recent rallies (empty)
      await screenshotHelper.takeScreenshot('rally_recent_rallies_initial');

      // Verify "No rallies yet" message is shown initially
      final noRalliesText = find.text('No rallies yet');
      if (noRalliesText.evaluate().isNotEmpty) {
        expect(noRalliesText, findsOneWidget);
      }

      // Scroll back up and record some actions
      await tester.scrollUntilVisible(
        find.text('Point Won'),
        -100,
        scrollable: find.byType(Scrollable).first,
      );
      await tester.pumpAndSettle();

      // Record a Kill action first
      final killButton = find.text('Kill');
      if (killButton.evaluate().isNotEmpty) {
        await tester.tap(killButton.first);
        await tester.pumpAndSettle();
      }

      // Then complete the rally
      final pointWonButton = find.text('Point Won');
      if (pointWonButton.evaluate().isNotEmpty) {
        await tester.tap(pointWonButton);
        await tester.pumpAndSettle();
      }

      // Scroll back to Recent Rallies
      await tester.scrollUntilVisible(
        find.text('Recent Rallies'),
        100,
        scrollable: find.byType(Scrollable).first,
      );
      await tester.pumpAndSettle();

      // Take screenshot of updated recent rallies
      await screenshotHelper.takeScreenshot('rally_recent_rallies_updated');
    });

    testWidgets('14. Player stats dialog displays all stats', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Take screenshot before opening dialog
      await screenshotHelper.takeScreenshot('rally_player_stats_before_dialog');

      // Find and tap the player stats icon in the app bar
      final playerStatsIcon = find.byIcon(Icons.people_rounded);
      if (playerStatsIcon.evaluate().isNotEmpty) {
        await tester.tap(playerStatsIcon);
        await tester.pumpAndSettle();

        // Take screenshot of player stats dialog
        await screenshotHelper.takeScreenshot('rally_player_stats_dialog_open');

        // Verify dialog title
        expect(find.text('Player Statistics'), findsOneWidget);

        // Verify stat chips are displayed (K, E, A, B, D, Asst, SA, SE, FBK)
        expect(find.textContaining('K:'), findsWidgets);

        // Close the dialog
        final closeButton = find.text('Close');
        if (closeButton.evaluate().isNotEmpty) {
          await tester.tap(closeButton);
          await tester.pumpAndSettle();

          // Take screenshot after closing dialog
          await screenshotHelper.takeScreenshot('rally_player_stats_dialog_closed');
        }
      }

      // Alternative: Find "View All" button in Player Stats section
      final viewAllButton = find.text('View All');
      if (viewAllButton.evaluate().isNotEmpty) {
        await tester.tap(viewAllButton);
        await tester.pumpAndSettle();

        // Take screenshot of player stats dialog
        await screenshotHelper.takeScreenshot('rally_player_stats_dialog_from_view_all');

        // Close dialog
        final closeBtn = find.text('Close');
        if (closeBtn.evaluate().isNotEmpty) {
          await tester.tap(closeBtn);
          await tester.pumpAndSettle();
        }
      }
    });
  });

  // ============================================================
  // TIMEOUTS & SUBSTITUTIONS TESTS (15-19)
  // ============================================================

  group('Timeouts and Substitutions Tests', () {
    testWidgets('15. Record timeout (Our team)', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Take screenshot before timeout
      await screenshotHelper.takeScreenshot('rally_timeout_our_before');

      // Find and tap Timeout button
      final timeoutButton = find.text('Timeout');
      if (timeoutButton.evaluate().isNotEmpty) {
        await tester.tap(timeoutButton);
        await tester.pumpAndSettle();

        // Take screenshot of timeout dialog
        await screenshotHelper.takeScreenshot('rally_timeout_dialog_open');

        // Verify timeout dialog is shown
        expect(find.text('Record Timeout'), findsOneWidget);

        // Select "Our Timeout"
        final ourTimeoutOption = find.text('Our Timeout');
        if (ourTimeoutOption.evaluate().isNotEmpty) {
          await tester.tap(ourTimeoutOption);
          await tester.pumpAndSettle();

          // Take screenshot after recording timeout
          await screenshotHelper.takeScreenshot('rally_timeout_our_recorded');
        }
      }
    });

    testWidgets('16. Record timeout (Opponent)', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find and tap Timeout button
      final timeoutButton = find.text('Timeout');
      if (timeoutButton.evaluate().isNotEmpty) {
        await tester.tap(timeoutButton);
        await tester.pumpAndSettle();

        // Take screenshot of timeout dialog
        await screenshotHelper.takeScreenshot('rally_timeout_opponent_dialog');

        // Select "Opponent Timeout"
        final opponentTimeoutOption = find.text('Opponent Timeout');
        if (opponentTimeoutOption.evaluate().isNotEmpty) {
          await tester.tap(opponentTimeoutOption);
          await tester.pumpAndSettle();

          // Take screenshot after recording timeout
          await screenshotHelper.takeScreenshot('rally_timeout_opponent_recorded');
        }
      }
    });

    testWidgets('17. Timeout limit enforcement (2 per set)', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Record first timeout
      final timeoutButton = find.text('Timeout');
      if (timeoutButton.evaluate().isNotEmpty) {
        await tester.tap(timeoutButton);
        await tester.pumpAndSettle();

        final ourTimeout = find.text('Our Timeout');
        if (ourTimeout.evaluate().isNotEmpty) {
          await tester.tap(ourTimeout);
          await tester.pumpAndSettle();
        }
      }

      // Take screenshot showing 1/2 timeouts
      await screenshotHelper.takeScreenshot('rally_timeout_1_of_2');

      // Record second timeout
      final timeoutButton2 = find.text('Timeout');
      if (timeoutButton2.evaluate().isNotEmpty) {
        await tester.tap(timeoutButton2);
        await tester.pumpAndSettle();

        final ourTimeout2 = find.text('Our Timeout');
        if (ourTimeout2.evaluate().isNotEmpty) {
          await tester.tap(ourTimeout2);
          await tester.pumpAndSettle();
        }
      }

      // Take screenshot showing 2/2 timeouts (max reached)
      await screenshotHelper.takeScreenshot('rally_timeout_2_of_2_max');

      // Verify timeout counter shows 2/2
      expect(find.textContaining('2 / 2'), findsWidgets);
    });

    testWidgets('18. Record substitution', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Take screenshot before substitution
      await screenshotHelper.takeScreenshot('rally_substitution_before');

      // Find and tap Substitution button
      final substitutionButton = find.text('Substitution');
      if (substitutionButton.evaluate().isNotEmpty) {
        await tester.tap(substitutionButton);
        await tester.pumpAndSettle();

        // Take screenshot of substitution dialog
        await screenshotHelper.takeScreenshot('rally_substitution_dialog_open');

        // Verify substitution dialog is shown
        expect(find.text('Record Substitution'), findsOneWidget);

        // Find Player Out dropdown
        final playerOutDropdown = find.widgetWithText(DropdownButtonFormField<dynamic>, 'Player Out');
        if (playerOutDropdown.evaluate().isNotEmpty) {
          await tester.tap(playerOutDropdown);
          await tester.pumpAndSettle();

          // Select first player
          final dropdownItems = find.byType(DropdownMenuItem<dynamic>);
          if (dropdownItems.evaluate().isNotEmpty) {
            await tester.tap(dropdownItems.first);
            await tester.pumpAndSettle();
          }
        }

        // Find Player In dropdown
        final playerInDropdown = find.widgetWithText(DropdownButtonFormField<dynamic>, 'Player In');
        if (playerInDropdown.evaluate().isNotEmpty) {
          await tester.tap(playerInDropdown);
          await tester.pumpAndSettle();

          // Select first bench player
          final dropdownItems = find.byType(DropdownMenuItem<dynamic>);
          if (dropdownItems.evaluate().isNotEmpty) {
            await tester.tap(dropdownItems.first);
            await tester.pumpAndSettle();
          }
        }

        // Take screenshot with selections made
        await screenshotHelper.takeScreenshot('rally_substitution_selections');

        // Tap Record button
        final recordButton = find.text('Record');
        if (recordButton.evaluate().isNotEmpty) {
          await tester.tap(recordButton);
          await tester.pumpAndSettle();

          // Take screenshot after recording substitution
          await screenshotHelper.takeScreenshot('rally_substitution_recorded');
        }
      }
    });

    testWidgets('19. Substitution limit enforcement (15 per set)', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Verify initial substitutions remaining counter
      // The UI shows "X / 15" for substitutions
      await screenshotHelper.takeScreenshot('rally_substitution_limit_initial');

      // Verify substitutions are shown with remaining count
      final substitutionText = find.textContaining('remaining');
      if (substitutionText.evaluate().isNotEmpty) {
        expect(substitutionText, findsWidgets);
      }

      // Note: Actually performing 15 substitutions would be impractical in a test
      // Instead, we verify the UI displays the limit correctly
      expect(find.textContaining('15'), findsWidgets);
    });
  });

  // ============================================================
  // ROTATION TESTS (20)
  // ============================================================

  group('Rotation Tests', () {
    testWidgets('20. Rotation tracking after point scored', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Take screenshot showing initial rotation (Set 1)
      await screenshotHelper.takeScreenshot('rally_rotation_initial');

      // Verify Set indicator is visible
      expect(find.text('Set'), findsWidgets);

      // Record a point won (which should advance rotation if we win)
      final killButton = find.text('Kill');
      if (killButton.evaluate().isNotEmpty) {
        await tester.tap(killButton.first);
        await tester.pumpAndSettle();
      }

      final pointWonButton = find.text('Point Won');
      if (pointWonButton.evaluate().isNotEmpty) {
        await tester.tap(pointWonButton);
        await tester.pumpAndSettle();

        // Take screenshot after point won (rotation should advance)
        await screenshotHelper.takeScreenshot('rally_rotation_after_win');
      }
    });
  });

  // ============================================================
  // APP BAR & MENU TESTS
  // ============================================================

  group('App Bar and Menu Tests', () {
    testWidgets('App bar displays Rally Capture title', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Take screenshot of app bar
      await screenshotHelper.takeScreenshot('rally_app_bar');

      // Verify Rally Capture title
      expect(find.text('Rally Capture'), findsOneWidget);
      expect(find.text('RC'), findsOneWidget);
    });

    testWidgets('More menu shows all options', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find and tap the more menu icon
      final moreIcon = find.byIcon(Icons.more_vert_rounded);
      if (moreIcon.evaluate().isNotEmpty) {
        await tester.tap(moreIcon);
        await tester.pumpAndSettle();

        // Take screenshot of menu open
        await screenshotHelper.takeScreenshot('rally_more_menu_open');

        // Verify menu options
        expect(find.text('Export'), findsOneWidget);
        expect(find.textContaining('Set Dashboard'), findsOneWidget);
        expect(find.textContaining('New Set'), findsOneWidget);
        expect(find.text('End Match'), findsOneWidget);

        // Dismiss menu
        await tester.tapAt(const Offset(10, 10));
        await tester.pumpAndSettle();
      }
    });

    testWidgets('Edit match button navigates to setup', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Find edit icon in app bar
      final editIcon = find.byIcon(Icons.edit_rounded);
      if (editIcon.evaluate().isNotEmpty) {
        await tester.tap(editIcon);
        await tester.pumpAndSettle(const Duration(seconds: 2));

        // Take screenshot - should navigate to match setup
        await screenshotHelper.takeScreenshot('rally_edit_navigation');

        // Verify navigation to match setup
        expect(find.byType(MatchSetupFlow), findsOneWidget);
      }
    });
  });

  // ============================================================
  // NEW SET & END MATCH TESTS
  // ============================================================

  group('New Set and End Match Tests', () {
    testWidgets('New Set dialog shows confirmation', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Open more menu
      final moreIcon = find.byIcon(Icons.more_vert_rounded);
      if (moreIcon.evaluate().isNotEmpty) {
        await tester.tap(moreIcon);
        await tester.pumpAndSettle();

        // Tap New Set option
        final newSetOption = find.textContaining('New Set');
        if (newSetOption.evaluate().isNotEmpty) {
          await tester.tap(newSetOption);
          await tester.pumpAndSettle();

          // Take screenshot of new set dialog
          await screenshotHelper.takeScreenshot('rally_new_set_dialog');

          // Verify dialog content
          expect(find.textContaining('Start Set'), findsOneWidget);
          expect(find.text('Cancel'), findsOneWidget);

          // Cancel to close dialog
          final cancelButton = find.text('Cancel');
          if (cancelButton.evaluate().isNotEmpty) {
            await tester.tap(cancelButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });

    testWidgets('End Match dialog shows confirmation with final score', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Open more menu
      final moreIcon = find.byIcon(Icons.more_vert_rounded);
      if (moreIcon.evaluate().isNotEmpty) {
        await tester.tap(moreIcon);
        await tester.pumpAndSettle();

        // Tap End Match option
        final endMatchOption = find.text('End Match');
        if (endMatchOption.evaluate().isNotEmpty) {
          await tester.tap(endMatchOption);
          await tester.pumpAndSettle();

          // Take screenshot of end match dialog
          await screenshotHelper.takeScreenshot('rally_end_match_dialog');

          // Verify dialog content
          expect(find.text('End Match'), findsWidgets);
          expect(find.text('Cancel'), findsOneWidget);
          expect(find.textContaining('Final Score'), findsOneWidget);

          // Cancel to close dialog
          final cancelButton = find.text('Cancel');
          if (cancelButton.evaluate().isNotEmpty) {
            await tester.tap(cancelButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });
  });

  // ============================================================
  // COMPLETE WORKFLOW TESTS
  // ============================================================

  group('Complete Workflow Tests', () {
    testWidgets('Full rally recording workflow', (tester) async {
      // Step 1: Set up match and navigate to rally capture
      await pumpApp(tester, initialRoute: '/match/setup');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      await screenshotHelper.takeStepScreenshot('rally_workflow', 1, 'match_setup');

      // Quick setup - enter opponent and select date
      final opponentField = find.widgetWithText(TextField, 'Opponent');
      if (opponentField.evaluate().isNotEmpty) {
        await tester.enterText(opponentField, 'Workflow Test Opponent');
        await tester.pumpAndSettle();
      }

      final dateButton = find.byIcon(Icons.calendar_today);
      if (dateButton.evaluate().isNotEmpty) {
        await tester.tap(dateButton);
        await tester.pumpAndSettle();
        final okButton = find.text('OK');
        if (okButton.evaluate().isNotEmpty) {
          await tester.tap(okButton);
          await tester.pumpAndSettle();
        }
      }

      // Select players
      final filterChips = find.byType(FilterChip);
      if (filterChips.evaluate().isNotEmpty) {
        final selectCount = filterChips.evaluate().length >= 6 ? 6 : filterChips.evaluate().length;
        for (var i = 0; i < selectCount; i++) {
          await tester.tap(filterChips.at(i));
          await tester.pumpAndSettle();
        }
      }

      await screenshotHelper.takeStepScreenshot('rally_workflow', 2, 'players_selected');

      // Navigate to rally capture (either via Start Match or direct navigation)
      await navigateToRallyCapture(tester, 'test-workflow-match');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      await screenshotHelper.takeStepScreenshot('rally_workflow', 3, 'rally_capture_screen');

      // Step 4: Record a kill
      final killButton = find.text('Kill');
      if (killButton.evaluate().isNotEmpty) {
        await tester.tap(killButton.first);
        await tester.pumpAndSettle();
      }

      await screenshotHelper.takeStepScreenshot('rally_workflow', 4, 'kill_recorded');

      // Step 5: Complete rally with win
      final pointWonButton = find.text('Point Won');
      if (pointWonButton.evaluate().isNotEmpty) {
        await tester.tap(pointWonButton);
        await tester.pumpAndSettle();
      }

      await screenshotHelper.takeStepScreenshot('rally_workflow', 5, 'rally_completed');

      // Step 6: Record another rally with error (loss)
      final atkErrButton = find.text('Atk Err');
      if (atkErrButton.evaluate().isNotEmpty) {
        await tester.tap(atkErrButton.first);
        await tester.pumpAndSettle();
      }

      await screenshotHelper.takeStepScreenshot('rally_workflow', 6, 'error_recorded');

      // Step 7: Check recent rallies
      await tester.scrollUntilVisible(
        find.text('Recent Rallies'),
        100,
        scrollable: find.byType(Scrollable).first,
      );
      await tester.pumpAndSettle();

      await screenshotHelper.takeStepScreenshot('rally_workflow', 7, 'recent_rallies');

      // Step 8: View player stats
      await tester.scrollUntilVisible(
        find.text('Point Won'),
        -100,
        scrollable: find.byType(Scrollable).first,
      );
      await tester.pumpAndSettle();

      final playerStatsIcon = find.byIcon(Icons.people_rounded);
      if (playerStatsIcon.evaluate().isNotEmpty) {
        await tester.tap(playerStatsIcon);
        await tester.pumpAndSettle();

        await screenshotHelper.takeStepScreenshot('rally_workflow', 8, 'player_stats_dialog');

        final closeButton = find.text('Close');
        if (closeButton.evaluate().isNotEmpty) {
          await tester.tap(closeButton);
          await tester.pumpAndSettle();
        }
      }
    });

    testWidgets('Complete set and start new set workflow', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      await screenshotHelper.takeStepScreenshot('set_workflow', 1, 'initial_set1');

      // Record some points
      for (var i = 0; i < 3; i++) {
        final killButton = find.text('Kill');
        if (killButton.evaluate().isNotEmpty) {
          await tester.tap(killButton.first);
          await tester.pumpAndSettle();
        }

        final pointWonButton = find.text('Point Won');
        if (pointWonButton.evaluate().isNotEmpty) {
          await tester.tap(pointWonButton);
          await tester.pumpAndSettle();
        }
      }

      await screenshotHelper.takeStepScreenshot('set_workflow', 2, 'after_some_points');

      // Start new set
      final moreIcon = find.byIcon(Icons.more_vert_rounded);
      if (moreIcon.evaluate().isNotEmpty) {
        await tester.tap(moreIcon);
        await tester.pumpAndSettle();

        final newSetOption = find.textContaining('New Set');
        if (newSetOption.evaluate().isNotEmpty) {
          await tester.tap(newSetOption);
          await tester.pumpAndSettle();

          await screenshotHelper.takeStepScreenshot('set_workflow', 3, 'new_set_dialog');

          // Confirm new set
          final startSetButton = find.textContaining('Start Set');
          if (startSetButton.evaluate().isNotEmpty) {
            await tester.tap(startSetButton);
            await tester.pumpAndSettle();

            await screenshotHelper.takeStepScreenshot('set_workflow', 4, 'set2_started');
          }
        }
      }
    });
  });

  // ============================================================
  // ERROR HANDLING TESTS
  // ============================================================

  group('Error Handling Tests', () {
    testWidgets('Rally capture handles loading state gracefully', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');

      // Take screenshot immediately (might catch loading state)
      await screenshotHelper.takeScreenshot('rally_loading_state');

      // Wait for loading to complete
      await tester.pumpAndSettle(const Duration(seconds: 3));

      // Take screenshot after loading
      await screenshotHelper.takeScreenshot('rally_loaded_state');

      // App should remain functional
      expect(find.byType(MaterialApp), findsOneWidget);
    });

    testWidgets('Point Won with no actions shows snackbar message', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Tap Point Won without recording any action first
      final pointWonButton = find.text('Point Won');
      if (pointWonButton.evaluate().isNotEmpty) {
        await tester.tap(pointWonButton);
        await tester.pumpAndSettle();

        // Take screenshot - should show a snackbar or still work
        await screenshotHelper.takeScreenshot('rally_point_won_no_action');
      }
    });

    testWidgets('Undo with nothing to undo shows appropriate message', (tester) async {
      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      if (find.byType(RallyCaptureScreen).evaluate().isEmpty) {
        await setupMatchAndNavigateToRallyCapture(tester);
        await tester.pumpAndSettle(const Duration(seconds: 3));
      }

      // Try to undo when nothing has been recorded
      // First check if undo is even enabled
      final undoButton = find.text('Undo');
      if (undoButton.evaluate().isNotEmpty) {
        await tester.tap(undoButton);
        await tester.pumpAndSettle();

        // Take screenshot - should show "Nothing to undo" snackbar
        await screenshotHelper.takeScreenshot('rally_undo_nothing');
      }
    });
  });

  // ============================================================
  // RESPONSIVE LAYOUT TESTS
  // ============================================================

  group('Responsive Layout Tests', () {
    testWidgets('Rally capture renders correctly in portrait', (tester) async {
      // Set portrait dimensions
      tester.view.physicalSize = const Size(390, 844);
      tester.view.devicePixelRatio = 3.0;

      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      // Take screenshot of portrait layout
      await screenshotHelper.takeScreenshot('rally_layout_portrait');

      // Verify layout renders without overflow
      expect(find.byType(MaterialApp), findsOneWidget);

      // Reset view
      tester.view.resetPhysicalSize();
      tester.view.resetDevicePixelRatio();
    });

    testWidgets('Rally capture renders correctly in landscape', (tester) async {
      // Set landscape dimensions
      tester.view.physicalSize = const Size(844, 390);
      tester.view.devicePixelRatio = 3.0;

      await pumpApp(tester, initialRoute: '/match/test-match/rally');
      await tester.pumpAndSettle(const Duration(seconds: 3));

      // Take screenshot of landscape layout
      await screenshotHelper.takeScreenshot('rally_layout_landscape');

      // Verify layout renders without overflow
      expect(find.byType(MaterialApp), findsOneWidget);

      // Reset view
      tester.view.resetPhysicalSize();
      tester.view.resetDevicePixelRatio();
    });
  });
}
